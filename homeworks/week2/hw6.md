1. 定義函式，參數類型未知，函式本身因為沒有被 called 所以我（電腦）不會執行它
2. 某種程度上，我會把未被使用、但已被定義的函式先保存起來，如果用戶在宣布函式之前就 call 函式，我同樣不會執行它，因為這就相當於函式未被定義，我也把它保存起來
3. 函式總共 9 行，第 10 行是空行，用戶在第 11 行要求執行函式，放進函式括號裡的是一個數列 [3, 5, 8, 13, 22, 35]，函式開始執行
4. 用戶
5. 回到之前定義好了的函式，執行第1行，經過 parsing 我知道參數 arr 的類型是數列，並按此往下執行
6. 執行第2行，設定變數 i 起始值為 0，檢查 i 是否小於數列 arr 的長度，如果小於，進入第 1 圈迴圈
7. 執行第3行，判斷位於數列 arr 之 i 位置的數值是否小於等於 0，此時 i 位置(亦即 0 位置)上是 3，由於 3 > 0 未達到回傳條件，執行迭代指令 i++，i 經過遞增變成 1，返回到第2行
8. 執行第2行，此時 i 等於 1 ，通過比較，i 依然小於數列 arr 的長度，因此再次進入迴圈
9. 執行第3行，檢查數列 arr 位置 1 上的值是否小於等於 0，因為 5 > 0 未滿足回傳條件，執行迭代指令 i++，經過遞增後 i 變成了 2，程式跑回第2行
10. 執行第2行，此時 i 等於 2 ，仍然小於參數 arr 的長度 6，因此再度進入迴圈
11. 執行第3行，判斷數列 arr 的 i 位置上的值是否小於等於 0，目前 i 位置(即位置2)上的值是 8，因為 8 > 0 不滿足回傳條件，執行指令 i++ 後 i 變成 3，回到第2行
12. 執行第2行，此時 i 是 3，數列 arr 的長度依然大於 i ，所以再次進入迴圈
13. 執行第3行，檢查數列 arr 的位置 3 上的值是否小於等於 0，由於 13 > 0 並未滿足回傳條件，i 通過執行指令 i++ 而變成 4，程式跑回到第2行
14. 執行第2行，現在 i 等於 4，i 依然小於數列 arr 的長度 6，仍然未達到回傳條件，須再度進入迴圈
15. 執行第3行，判斷數列 arr 的第 4 位上的值 22 是否小於等於 0，因為 22 > 0 未達到回傳條件，執行 i++ 後 i 遞增成 5，程序跑回第2行
16. 執行第2行，目前 i 等於 5，雖然很接近參數 arr 的長度 6，但依然比 6 小，因此再次進入迴圈
17. 執行第3行，檢查數列 arr 的第 5 位是否小於等於 0，此時這個位置上的值是 35，因為 35 > 0 仍然沒達到回傳條件，i 經過執行指令 i++ 後變成 6，回到第2行
18. 執行第2行，此時 i 等於 6 了，與數列 arr 的長度 6 相等，因此結束第一個迴圈
19. 執行到第5行，將變數 i 起始值定為 2，要求每一次迭代都必須判斷 i 是否小於數列 arr 的長度，迭代時執行 i++
20. 進入第 2 個迴圈，執行第6行，判斷 arr[i] 是否不等於 arr[i-1] + arr[i-2]，而目前 i 等於 2，arr[i] 等於 8，可得 arr[i-1] + arr[i-2] 的結果為 8，兩邊都等於 8，不符合回傳 'invalid' 的條件，執行指令 i++ 後 i 的值變成3，程式跑回第 2 個迴圈的開端
21. 執行第5行，現在 i 等於 3，依然小於參數 arr 長度 6，須再次進入迴圈
22. 執行第6行，檢查 arr[i] 是否不等於 arr[i-1] + arr[i-2]，因為 arr[3] == 13，而 arr[2] + arr[1] == 13，兩邊都等於 13 並未達到回傳條件，執行 i++ 使 i 遞增到 4，回到第5行
23. 執行第5行，目前 i 等於 4，仍然小於數列 arr 的長度 6，再度進入迴圈
24. 執行第6行，判斷 arr[i] 是否步等於 arr[i-1] + arr[i-2]，此時觀察到 arr[4] == 22，而 arr[2] + arr[1] == 21 兩邊並不相等，此時滿足回傳條件，程式回傳 'invalid' 
25. 執行完畢
