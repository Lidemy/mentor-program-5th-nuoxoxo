```js
function isValid(arr) {
  for(var i=0; i<arr.length; i++) {
    if (arr[i] <= 0) return 'invalid'
  }
  for(var i=2; i<arr.length; i++) {
    if (arr[i] !== arr[i-1] + arr[i-2]) return 'invalid'
  }
  return 'valid'
}

isValid([3, 5, 8, 13, 22, 35])
```
## 執行流程
1. 執行第1行，定義函式 isValid()，參數類型是數列
2. 執行第2行，設定變數 i 等於 0，檢查 i 是否 < 數列 arr 的長度，是的話進入第1圈迴圈
3. 執行第3行，判斷處於數列 arr 的 i 位置的數值是否 <= 0，此時 i 位置(即 0 位置)上的是 3，3 > 0，不滿足回傳條件，執行迭代指令 i++，i 變成 1，返回到第2行
4. 執行第2行，此時 i 等於 1，i 依然 < 數列 arr 的長度，再次進入迴圈
5. 執行第3行，檢查數列 arr 位置 1 上的值是否 <= 0，5 > 0，他不滿足回傳條件，執行指令 i++，i 變成 2，跑回第2行
6. 執行第2行，因為 i == 2，依然 < 數列 arr 的長度，再次進入迴圈
7. 執行第3行，判斷數列 arr 的 i 位置上的值是否 <= 0，現在 i (即位置2) 上是 8，8 > 0 不滿足回傳條件，執行指令 i++，i 變成3，回到第2行
8. 執行第2行，此時 i 等於 3，i 依然 < 數列 arr 的長度，再次進入迴圈
9. 執行第3行，看看數列 arr 的位置 3 上的值是否 <= 0，13 > 0 不滿足回傳條件，執行指令 i++，i 變成 4，回到第2行
10. 執行第2行，i 這邊現在 4，i 依然 < 數列 arr 的長度 6，你看她不滿足回傳條件，但很接近了，再次進入迴圈吧
11. 執行第3行，數列 arr 的第 4 位上的值是多少，是 22，判斷結果 22 > 0，錯過回傳條件，執行 i += 1，i 變成 5，跑回第2行
12. 執行第2行，現在 i == 5，十分接近數列 arr 的長度 6，但還是比 6 小，進入迴圈吧
13. 執行第3行，數列 arr 的位置 5 上的值是 35，35 > 0 仍然沒達到回傳條件，執行指令 i++，i 變成 6，回到第2行
14. 執行第2行，終於 i == 6 了，arr 的長度也是 6，i 不再小於數列長度，結束第一個迴圈
15. 來到第5行，設定變數 i 的起點為 2，判斷 i 是否 < 數列長度，設定迭代時會發生 i++
16. 第一次進入第二個迴圈
17. 執行第6行，判斷 arr[i] 是不是等於 arr[i-1] + arr[i-2]，函式應該是要判斷費氏數列，目前 i == 2，arr[i] == 8，而 arr[i-1] + arr[i-2] == 8，兩邊都等於 8，和回傳 'invalid' 的條件失之交臂，執行指令 i++，拋匯第二個迴圈的一開始
18. 執行第5行，目前 i 已變成 3，小於 arr 長度 6，進入迴圈吧
19. 執行第6行，一起來看 arr[i] 是否等於 arr[i-1] + arr[i-2]，arr[3] == 13，而 arr[2] + arr[1] == 13，兩邊都等於 13，不滿足回傳的條件，執行 i += 1，i 變成 4，回到第5行
20. 執行第5行，現在 i 通過 iterate 變成 4，短於 arr 長度 6，回到迴圈！
21. 執行第6行，檢查 arr[i] 是否等於 arr[i-1] + arr[i-2]，arr[4] == 22，而 arr[2] + arr[1] == 21，兩邊不想等！參數 arr 滿足回傳條件，程式 return 'invalid'
22. 執行完畢

